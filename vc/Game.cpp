#include "stdafx.h"
#include "game.h"

// 不含分数的单步运算
// 参数说明：
// result		[out] 接收计算结果，如果运算成功的话
// left			[in] 运算符左边的表达式
// right		[in] 运算符右边的表达式
// iOperator	[in] 运算符
// 返回值：
// 如果可以运算，返回true，否则返回false
static bool WINAPI Operate(EXPRESSION& result,const EXPRESSION& left,const EXPRESSION& right, __int8 iOperator)
{
	result.iLeft =left.iIndex;
	result.iRight =right.iIndex;
	switch(iOperator)
	{
	case ADD:
		result.nNumerator =left.nNumerator+right.nNumerator;
		break;
	case SUBTRACT:
		// 结果不能为0
		if(left.nNumerator==right.nNumerator)
			return false;
		// 确保被减数大于减数
		if(left.nNumerator<right.nNumerator)
		{
			swap(result.iLeft,result.iRight);
		}
		result.nNumerator =Left(&result)->nNumerator-Right(&result)->nNumerator;
		break;
	case MULTIPLY:
		result.nNumerator =left.nNumerator*right.nNumerator;
		break;
	case DIVIDE:
		// 确保被除数大于或等于除数
		if(left.nNumerator<right.nNumerator)
		{
			swap(result.iLeft,result.iRight);
		}
		// 要求能够整除
		if(0!=(Left(&result)->nNumerator%Right(&result)->nNumerator))
			return false;
		result.nNumerator =Left(&result)->nNumerator/Right(&result)->nNumerator;
		break;
	default:
		ATLASSERT(!_T("Invalid operator!"));
		return false;
	}
	result.iOperator =iOperator;
	return true;
}
// 求最大公约数Stein算法
// 参数说明：
// a			[in] 一个数
// b			[in] 一个数
// 返回值：
// 最大公约数
static int WINAPI GetGreatestCommonDivisor(int a, int b)
{
	int c = 1; 
	while(a && b)
	{ 
		while (!(a&1) && !(b&1))
		{ 
			a >>=1;
			b >>=1;
			c <<=1;
		} 
		while(!(a&1))
		{ 
			a >>=1;
		} 
		while(!(b&1))
		{
			b >>=1;
		}
		int m =(a+b)>>1;
		int n =((a>b)?(a-b):(b-a))>>1;
		a =m;
		b =n;
	} 
	return (a?a:b)*c;
}
// 含分数的单步运算
// 参数说明：
// result		[out] 接收计算结果，如果运算成功的话
// left			[in] 运算符左边的表达式
// right		[in] 运算符右边的表达式
// iOperator	[in] 运算符
// 返回值：
// 如果可以运算，返回true，否则返回false
static bool WINAPI FractionalOperate(EXPRESSION& result,const EXPRESSION& left,const EXPRESSION& right, __int8 iOperator)
{
	result.iLeft =left.iIndex;
	result.iRight =right.iIndex;
	switch(iOperator)
	{
	case ADD:
		result.nDenominator =left.nDenominator*right.nDenominator;
		result.nNumerator =left.nNumerator*right.nDenominator+right.nNumerator*left.nDenominator;
		break;
	case SUBTRACT:
		result.nNumerator =left.nNumerator*right.nDenominator-right.nNumerator*left.nDenominator;
		// 结果不能为0
		if(!result.nNumerator)
			return false;
		result.nDenominator =left.nDenominator*right.nDenominator;
		// 确保被减数大于减数
		if(result.nNumerator<0)
		{
			swap(result.iLeft,result.iRight);
			result.nNumerator =-result.nNumerator;
		}
		break;
	case MULTIPLY:
		result.nDenominator =left.nDenominator*right.nDenominator;
		result.nNumerator =left.nNumerator*right.nNumerator;
		break;
	case DIVIDE:
		result.nDenominator =left.nDenominator*right.nNumerator;
		result.nNumerator =left.nNumerator*right.nDenominator;
		// 确保被除数大于或等于除数
		if(result.nDenominator>result.nNumerator)
		{
			swap(result.iLeft,result.iRight);
			swap(result.nDenominator,result.nNumerator);
		}
		{
		short gcd =(short)GetGreatestCommonDivisor(result.nNumerator,result.nDenominator);
		if(gcd>1)
		{
		result.nNumerator =result.nNumerator/gcd;
		result.nDenominator =result.nDenominator/gcd;
		}
		}
		break;
	case PROPER_FRACTION:
		result.nDenominator =left.nDenominator*right.nNumerator;
		result.nNumerator =left.nNumerator*right.nDenominator;
		// 确保被除数小于除数
		if(result.nDenominator == result.nNumerator)
			return false;
		if(result.nDenominator<result.nNumerator)
		{
			swap(result.iLeft,result.iRight);
			swap(result.nDenominator,result.nNumerator);
		}
		{
		short gcd =(short)GetGreatestCommonDivisor(result.nNumerator,result.nDenominator);
		if(gcd>1)
		{
		result.nNumerator =result.nNumerator/gcd;
		result.nDenominator =result.nDenominator/gcd;
		}
		}
		break;
	default:
		ATLASSERT(!_T("Invalid operator!"));
		return false;
	}
	result.iOperator =iOperator;
	return true;
}

// ------------------------------------------------------------------------------------------------
// CMake24

void CMake24::Attach(const short pOperands[])
{
	ATLASSERT(pOperands[0]<=pOperands[1] && pOperands[1]<=pOperands[2] && pOperands[2]<=pOperands[3]);
	m_keys.RemoveAll();
	ZeroMemory(m_pExpressions,sizeof(EXPRESSION)*(NUM_OPERAND*2-1));
	for(__int8 i=0;i<NUM_OPERAND*2-1;i++)
	{
		m_pExpressions[i].nDenominator =1;
		m_pExpressions[i].iIndex =i;
		m_pExpressions[i].iLeft =-1;
		m_pExpressions[i].iRight =-1;
	}
	for(int j=0;j<NUM_OPERAND;j++)
	{
		m_pExpressions[j].nNumerator =pOperands[j];
	}
}
bool CMake24::AutoOperate(bool fAllKey)
{
	m_keys.RemoveAll();
	RecursiveOperate(Operate,fAllKey);
	if(m_keys.IsEmpty())
	{
		RecursiveFractionalOperate(fAllKey);
		return !m_keys.IsEmpty();
	}
	
	if(m_keys.GetCount()>1)
	{
		qsort_s(&m_keys[0],m_keys.GetCount(),sizeof(KEYDIFFICULTY),CompareKey,NULL);
		CKeys keys;
		keys.Add(m_keys[0]);
		for(int i=1;i<(int)m_keys.GetCount();i++)
		{
			if(lstrcmp(m_keys[i].key.szExpression,m_keys[i-1].key.szExpression)!=0)
			{
				keys.Add(m_keys[i]);
			}
		}
		m_keys.RemoveAll();
		m_keys.Append(keys);
	}

#if defined(_DEBUG)
	//for(int i=0;i<(int)m_keys.GetCount();i++)
	//{
	//	ATLTRACE(_T("%s\n"),m_keys[i].key.szExpression);
	//}
#endif
	return true;
}
int CMake24::GetKeys(KEY pKeys[] ,int nMax) const
{
	int n =min(nMax,(int)m_keys.GetCount());
	for(int i=n-1;i>=0;i--)
	{
		memcpy(pKeys[i].szExpression,m_keys[i].key.szExpression,sizeof(pKeys[i].szExpression));
	}
	return n;
}
#if defined(_DEBUG)
int CMake24::GetDifficulty() const
{
	if(m_keys.IsEmpty())
		return DIFFICULTY_INVALID;

	// 根据所有答案的难度总评试题难度
	int nNumerator =m_keys[0].nDifficulty;
	if(DIFFICULTY_HIGHEST==nNumerator)
		return DIFFICULTY_HIGHEST;
	int nDenominator =1;
	for(int k=m_keys.GetCount()-1;k>=1;k--)
	{
		int nDifficulty =m_keys[k].nDifficulty;
		nDenominator = nDenominator*nDifficulty+nNumerator;
		nNumerator *=nDifficulty;
		if(nNumerator<nDenominator)
			return 0;
		if(nNumerator%nDenominator==0)
		{
			nNumerator/=nDenominator;
			nDenominator =1;
		}
		ATLASSERT(nNumerator<nDifficulty*nDenominator);
	}
	return nNumerator/nDenominator;
}
WORD CMake24::GetFirstStep() const
{
	ATLASSERT(!m_keys.IsEmpty());
	int nDifficulty =m_keys[0].nDifficulty;
	__int8 iOperator =m_keys[0].iOperator;
	__int8 iLeft =m_keys[0].iLeft;
	__int8 iRight =m_keys[0].iRight;
	for(int k=m_keys.GetCount()-1;k>=1;k--)
	{
		if(m_keys[k].nDifficulty<nDifficulty)
		{
			nDifficulty =m_keys[k].nDifficulty;
			iOperator =m_keys[k].iOperator;
			iLeft =m_keys[k].iLeft;
			iRight =m_keys[k].iRight;
		}
	}
	return (iOperator<<4)|(iRight<<2)|iLeft;
}

void CMake24::MakeTable(short nMax, short nMin)
{
	CAtlArray<DWORD> pDifficulties[DIFFICULTY_HIGHEST+1];
	short pOperands[NUM_OPERAND];
	CMake24 make24;
	{
	for(short i=1;i<=nMax;i++)
	{
		pOperands[0] =i;
		for(short j=i;j<=nMax;j++)
		{
			pOperands[1] =j;
			for(short k=j;k<=nMax;k++)
			{
				pOperands[2] =k;
				for(short l=max(nMin,k);l<=nMax;l++)
				{
					pOperands[3] =l;
					make24.Attach(pOperands);
					if(make24.AutoOperate())
					{
						int nDifficulty =make24.GetDifficulty();
						ATLASSERT(nDifficulty<=DIFFICULTY_HIGHEST);
						pDifficulties[nDifficulty].Add(
							MAKELONG(((i<<12)|(j<<8)|(k<<4)|l),make24.GetFirstStep()));
					}
				}
			}
		}
	}
	}
	ATLTRACE(_T("\tconst WORD pQuestions[] ={\n"));
	{
	for(int i=0;i<=DIFFICULTY_HIGHEST;i++)
	{
		ATLASSERT(pDifficulties[i].GetCount()>0);
		const DWORD* pQuestions =&pDifficulties[i][0];
		for(int j=0;j<(int)pDifficulties[i].GetCount();j++)
		{
			if(0==(j%16))
			{
				ATLTRACE(_T("\t\t"));
			}
			ATLTRACE(_T("0x%04x,"),LOWORD(pQuestions[j]));
			if(15==(j%16))
			{
				ATLTRACE(_T("\n"));
			}
		}
		if((pDifficulties[i].GetCount()%16)!=0)
		{
			ATLTRACE(_T("\t\n"));
		}
	}
	}
	ATLTRACE(_T("\t\t0\n\t};\n"));
	ATLTRACE(_T("\tconst int pCounts[] ={\n"));
	{
	for(int j=0;j<=DIFFICULTY_HIGHEST;j++)
	{
		ATLTRACE(_T("\t\t%d,\n"),pDifficulties[j].GetCount());
	}
	}
	ATLTRACE(_T("\t\t0\n\t};\n"));
	ATLTRACE(_T("\tconst WORD* ppQuestions[] ={\n\tpQuestions,\n"));
	int n =0;
	{
	for(int k=0;k<DIFFICULTY_HIGHEST;k++)
	{
		n+=pDifficulties[k].GetCount();
		ATLTRACE(_T("\t\tpQuestions+%d,\n"),n);
	}
	}
	ATLTRACE(_T("\t\t0\n\t};\n"));
	ATLTRACE(_T("\tconst BYTE pHints[] ={\n"));
	{
	for(int i=0;i<=DIFFICULTY_HIGHEST;i++)
	{
		ATLASSERT(pDifficulties[i].GetCount()>0);
		const DWORD* pQuestions =&pDifficulties[i][0];
		for(int j=0;j<(int)pDifficulties[i].GetCount();j++)
		{
			if(0==(j%16))
			{
				ATLTRACE(_T("\t\t"));
			}
			ATLTRACE(_T("0x%02x,"),HIWORD(pQuestions[j]));
			if(15==(j%16))
			{
				ATLTRACE(_T("\n"));
			}
		}
		if((pDifficulties[i].GetCount()%16)!=0)
		{
			ATLTRACE(_T("\t\n"));
		}
	}
	}
	ATLTRACE(_T("\t\t0\n\t};\n"));
}
#endif

// 计算24，穷举所有的方式，该函数支持递归调用
// 参数说明：
// pfnOperate	[in] 实现单步运算的回调函数，可以是Operate()或FractionalOperate()
// fAllKey		[in] 是否需要获取所有答案，如果为false，则只要得到一个答案即退出循环
// 返回值：
// 如果得到至少一个答案，则返回true，否则返回false
bool CMake24::RecursiveOperate(
	bool (WINAPI pfnOperate)(EXPRESSION&,const EXPRESSION&,const EXPRESSION&, __int8),
	bool fAllKey)
{
	// 定位保存单步运算结果的位置
	EXPRESSION* pExpression =NULL;
	{
	for(__int8 i=NUM_OPERAND;i<NUM_OPERAND*2-1;i++)
	{
		if(0==m_pExpressions[i].iOperator)
		{
			pExpression =m_pExpressions+i;
			break;
		}
	}
	}
	// 如果找不到，说明该路经已经到达末端，应检查计算结果是否为24
	if(!pExpression)
	{
		pExpression =m_pExpressions+sizeof(m_pExpressions)/sizeof(m_pExpressions[0])-1;
		if(pExpression->nNumerator!=RESULT_VALUE*pExpression->nDenominator)
			return false;
		EXPRESSION pExpressions[NUM_OPERAND*2-1];
		memcpy(pExpressions,m_pExpressions,sizeof(pExpressions));
		Normalize(pExpressions);
		KEYDIFFICULTY key;
		ToString(pExpressions+NUM_OPERAND*2-2,key.key.szExpression,sizeof(key.key.szExpression)/sizeof(TCHAR));
#if defined(_DEBUG)
		key.iReserved =0;
		key.iOperator =pExpressions[NUM_OPERAND].iOperator;
		key.iLeft =pExpressions[NUM_OPERAND].iLeft;
		key.iRight =pExpressions[NUM_OPERAND].iRight;
		key.nDifficulty =( (FractionalOperate==pfnOperate)?DIFFICULTY_HIGHEST:GetDifficulty(pExpressions) );
#endif
		m_keys.Add(key);
		return true;
	}
	for(__int8 i=0;i<pExpression->iIndex;i++)
	{
		if(HasUsed(i))
			continue;
		for(__int8 j=i+1;j<pExpression->iIndex;j++)
		{
			if(HasUsed(j))
				continue;
			for(__int8 k=ADD;k<NUM_OPERATION;k++)
			{
				ATLASSERT(pExpression->iIndex>i && pExpression->iIndex>j);
				if(pfnOperate(*pExpression,m_pExpressions[i],m_pExpressions[j],k))
				{
					ATLASSERT(pExpression->iIndex>pExpression->iLeft && pExpression->iIndex>pExpression->iRight);
					if(RecursiveOperate(pfnOperate,fAllKey) && !fAllKey)
						return true;
					pExpression->iOperator =0;
					pExpression->iLeft =-1;
					pExpression->iRight =-1;
				}
			}
		}
	}
	return !m_keys.IsEmpty();
}
// 以分数方式计算24，得到一个答案即可。该函数确保第一步即位分数运算
// 返回值：
// 如果得到答案，则返回true，否则返回false
bool CMake24::RecursiveFractionalOperate(bool fAllKey)
{
	for(__int8 i=0;i<NUM_OPERAND;i++)
	{
		for(__int8 j=i+1;j<NUM_OPERAND;j++)
		{
			for(__int8 k=DIVIDE;k<=PROPER_FRACTION;k++)
			{
				EXPRESSION& result =m_pExpressions[NUM_OPERAND];
				if(FractionalOperate(result,m_pExpressions[i],m_pExpressions[j],k))
				{
					if( (DIVIDE==k) && (result.nNumerator%result.nDenominator==0) )
						continue;
					if(RecursiveOperate(FractionalOperate,fAllKey))
						return true;
				}
			}
		}
	}
	return false;
}
inline bool CMake24::HasUsed(__int8 iIndex) const
{
	for(__int8 i=NUM_OPERAND;i<sizeof(m_pExpressions)/sizeof(m_pExpressions[0])-1;i++)
	{
		const EXPRESSION* pExpression =m_pExpressions+i;
		if(!pExpression->iOperator)
			return false;
		if(pExpression->iLeft==iIndex || pExpression->iRight==iIndex)
			return true;
	}
	return false;
}

// 元素比较，由qsort_s函数调用
int CMake24::CompareKey(void* , const void* pKey1, const void* pKey2)
{
	return lstrcmp(((const KEYDIFFICULTY*)pKey1)->key.szExpression,((const KEYDIFFICULTY*)pKey2)->key.szExpression);
}

// 规范计算步骤，使之便于比较
// 参数说明：
// pExpressions	[in, out] 待规范的表达式数组，其中包含计算步骤
// 说明：
// 这里假定计算24的4个数是按从小到大的顺序排列的
void CMake24::Normalize(EXPRESSION pExpressions[])
{
	Sort(pExpressions+NUM_OPERAND*2-2);

	// 确保iIndex>iLeft && iIndex>iRight
	{
	for(__int8 i=NUM_OPERAND;i<NUM_OPERAND*2-2;   ) // 注意没有i++
	{
		EXPRESSION* p =pExpressions+i;
		EXPRESSION* pNext =NULL;
		if(p->iLeft>i)
		{
			pNext =Left(p);
			p->iLeft =i;
		}
		else if(p->iRight>i)
		{
			pNext =Right(p);
			p->iRight =i;
		}
		if(!pNext)
		{
			i++;
			continue;
		}
		for(__int8 j=i+1;j<NUM_OPERAND*2-1;j++)
		{
			if(pExpressions[j].iLeft==i)
			{
				pExpressions[j].iLeft =pNext->iIndex;
				break;
			}
			if(pExpressions[j].iRight==i)
			{
				pExpressions[j].iRight =pNext->iIndex;
				break;
			}
		}
		swap(*p,*pNext);
		swap(p->iIndex,pNext->iIndex);
	}
	}
#if defined(_DEBUG)
	// 使iLeft<iRight,如果iLeft>=NUM_OPERAND且iRight>=NUM_OPERAND的话
	{
	for(__int8 i=NUM_OPERAND+2;i<NUM_OPERAND*2-1;i++)
	{
		EXPRESSION* p =pExpressions+i;
		if(p->iLeft<p->iRight && p->iLeft>=NUM_OPERAND)
		{
			swap(*Left(p),*Right(p));
			swap(Left(p)->iIndex,Right(p)->iIndex);
			swap(p->iLeft,p->iRight);
		}
	}
	}
#endif
	/*
	// 硬编码处理方式
	if(5==pExpressions[6].iLeft)
	{ // 使iLeft<iRight,如果iLeft>=NUM_OPERAND且iRight>=NUM_OPERAND的话
		if(4==pExpressions[6].iRight)
		{
			swap(pExpressions[4],pExpressions[5]);
			pExpressions[4].iIndex =4;
			pExpressions[5].iIndex =5;
			pExpressions[6].iLeft =4;
			pExpressions[6].iRight =5;
		}
	}
	else if(5!=pExpressions[6].iRight)
	{ // 确保iIndex>iLeft && iIndex>iRight
		swap(pExpressions[4],pExpressions[5]);
		pExpressions[4].iIndex =4;
		pExpressions[5].iIndex =5;
		if(5==pExpressions[5].iLeft)
		{
			pExpressions[5].iLeft =4;
		}
		else
		{
			pExpressions[5].iRight =4;
		}
		if(4==pExpressions[6].iLeft)
		{
			pExpressions[6].iLeft =5;
		}
		else
		{
			pExpressions[6].iRight =5;
		}
	}
	*/

#if defined(_DEBUG)
	// 如果数字相等，应确保前一个数字先被调用
	// 如果两个相等的数字参与运算，对于加法和乘法，索引小的在左，对于除法，索引大的在左
	for(__int8 j=0;j<NUM_OPERAND-1;j++)
	{
		short nNumerator =pExpressions[j].nNumerator;
		if(nNumerator!=pExpressions[j+1].nNumerator)
			continue;
		__int8 iMax =j+1;
		for(   ;iMax<NUM_OPERAND-1;iMax++)
		{
			if(pExpressions[iMax+1].nNumerator!=nNumerator)
				break;
		}
		for(__int8 k=NUM_OPERAND;k<NUM_OPERAND*2-2;k++)
		{
			EXPRESSION* p =pExpressions+k;
			if( (p->iLeft<j || p->iLeft>iMax) && (p->iRight<j || p->iRight>iMax) )
				continue;
			if(p->iLeft==j)
			{
				if(DIVIDE==p->iOperator && p->iRight>j && p->iRight<=iMax)
				{
					swap(p->iLeft,p->iRight);
				}
				break;
			}
			if(p->iRight==j)
			{
				if((ADD==p->iOperator || MULTIPLY==p->iOperator) && p->iLeft>j && p->iLeft<=iMax)
				{
					swap(p->iLeft,p->iRight);
				}
				break;
			}
			for(__int8 l=k+1;l<NUM_OPERAND*2-1;l++)
			{
				__int8& iIndex =((p->iLeft>j && p->iLeft<=iMax) ? ( (p->iRight>j && p->iRight<=iMax && DIVIDE==p->iOperator)?p->iRight:p->iLeft) : p->iRight);
				if(pExpressions[l].iLeft==j)
				{
					swap(pExpressions[l].iLeft,iIndex);
					break;
				}
				if(pExpressions[l].iRight==j)
				{
					swap(pExpressions[l].iRight,iIndex);
					break;
				}
			}
			break;
		}
	}
#endif
}
// 运用交换律对表达式进行内部排序，该函数支持递归运算
// 参数说明：
// pExpression	[in, out] 指向待排序的表达式
// 说明：
// 该函数当前不能解决位置上的不规范问题
void CMake24::Sort(EXPRESSION* pExpression)
{
	// 递归结束条件为遇到常数表达式
	if(!pExpression->iOperator)
		return;

	Sort(Right(pExpression));
	for(bool fDirty =true;fDirty;)
	{
		EXPRESSION* pLeft =Left(pExpression);
		EXPRESSION* pRight =Right(pExpression);
		Sort(pLeft);
		if(ADD==pExpression->iOperator || MULTIPLY==pExpression->iOperator)
		{
			__int8 iConverseOperator =( (ADD==pExpression->iOperator)?SUBTRACT:DIVIDE);
			if(iConverseOperator==pRight->iOperator || 	// a+(b-c) = (a+b)-c a*(b/c) =(a*b)/c
				pExpression->iOperator==pRight->iOperator)	// a+(b+c) = (a+b)+c a*(b*c) = (a*b)*c
			{
				__int8 iOperator =pRight->iOperator;
				EXPRESSION* p =Right(pRight);
				FractionalOperate(*pRight,*pLeft,*Left(pRight),pExpression->iOperator);
				FractionalOperate(*pExpression,*pRight,*p,iOperator);
			}
			else if(iConverseOperator==pLeft->iOperator || 	// (a-b)+c = (a+c)-b (a/b)*c = (a*c)/b
				(pExpression->iOperator==pLeft->iOperator &&	// (a+b)+c = (a+c)+b (a*b)*c = (a*c)*b
				CompareExpression(*pRight,*Right(pLeft))<0 ) )
			{
				__int8 iOperator =pLeft->iOperator;
				EXPRESSION* p =Right(pLeft);
				FractionalOperate(*pLeft,*Left(pLeft),*pRight,pExpression->iOperator);
				FractionalOperate(*pExpression,*pLeft,*p,iOperator);
			}
			else
			{
				fDirty =false;
			}
		}
		else
		{
			__int8 iConverseOperator =( (SUBTRACT==pExpression->iOperator)?ADD:MULTIPLY);
			if(pExpression->iOperator==pRight->iOperator)	// a-(b-c) = (a+c)-b a/(b/c) = (a*c)/b
			{
				EXPRESSION* p =Left(pRight);
				FractionalOperate(*pRight,*pLeft,*Right(pRight),iConverseOperator);
				FractionalOperate(*pExpression,*pRight,*p,pExpression->iOperator);
			}
			else if(iConverseOperator==pRight->iOperator)	// a-(b+c) = (a-b)-c a/(b*c) = (a/b)/c
			{
				EXPRESSION* p =Right(pRight);
				FractionalOperate(*pRight,*pLeft,*Left(pRight),pExpression->iOperator);
				FractionalOperate(*pExpression,*pRight,*p,pExpression->iOperator);
			}
			else if(pExpression->iOperator==pLeft->iOperator &&	// (a-b)-c = (a-c)-b (a/b)/c = (a/c)/b
				CompareExpression(*Right(pLeft),*pRight)<0)
			{
				EXPRESSION* p =Right(pLeft);
				FractionalOperate(*pLeft,*Left(pLeft),*pRight,pExpression->iOperator);
				FractionalOperate(*pExpression,*pLeft,*p,pExpression->iOperator);
			}
			else
			{
				fDirty =false;
			}
		}
	}
	if(ADD==pExpression->iOperator || MULTIPLY==pExpression->iOperator)
	{
		EXPRESSION* pLeft =Left(pExpression);
		EXPRESSION* pRight =Right(pExpression);
		if(pExpression->iOperator!=pLeft->iOperator &&
			CompareExpression(*pLeft,*pRight)>0)
		{	// make sure left<=right
			swap(pExpression->iLeft,pExpression->iRight);
		}
	}
}
// 比较两个表达式的大小，该函数由Sort函数调用
// 参数说明：
// a	[in] 待比较的表达式
// b	[in] 待比较的表达式
// 返回值：
// 如果a>b，返回大于0的数；如果a<b，返回小于0的数；如果相等，返回0
inline int CMake24::CompareExpression(const EXPRESSION& a,const EXPRESSION& b)
{
	int nValue =a.nNumerator*b.nDenominator-a.nDenominator*b.nNumerator;
	if(0==nValue)
	{
		nValue =a.iOperator-b.iOperator;
		if(0==nValue && 0!=a.iOperator)
		{
			nValue =Left(&a)->nNumerator*Left(&b)->nDenominator-Left(&a)->nDenominator*Left(&b)->nNumerator;
			// if(0==nValue)
			// {
			//	nValue =a.iIndex-b.iIndex;
			// }
		}
	}
	return nValue;
}

#if defined(_DEBUG)
// 计算答案的难度
// 参数：
// pExpressions	[in, length_is(sizeof(EXPRESSION)*7)] 答案
// 返回值：
// 返回答案难度
int CMake24::GetDifficulty(const EXPRESSION pExpressions[])
{
	__int8 iOperator1 =pExpressions[4].iOperator;
	__int8 iOperator2 =pExpressions[5].iOperator;
	__int8 iOperator3 =pExpressions[6].iOperator;
	bool bLowLevelOperation1 =(ADD==iOperator1 || SUBTRACT==iOperator1);
	bool bLowLevelOperation2 =(ADD==iOperator2 || SUBTRACT==iOperator2);
	bool bLowLevelOperation3 =(ADD==iOperator3 || SUBTRACT==iOperator3);
	int nDifficulty =3;
	if(bLowLevelOperation1==bLowLevelOperation2)
	{
		--nDifficulty;
	}
	if(bLowLevelOperation2==bLowLevelOperation3)
	{
		--nDifficulty;
	}
	if(3==nDifficulty && ADD!=iOperator3 && MULTIPLY!=iOperator3)
	{
		++nDifficulty;
	}
	return nDifficulty;
}
#endif

int CMake24::ToString(const EXPRESSION* pExpression,TCHAR pszExpression[],int nMax)
{
	if(nMax<2)
		return 0;
		
	if(!pExpression->iOperator)
		return (0==_itot_s(pExpression->nNumerator,pszExpression,nMax,10)?lstrlen(pszExpression):0);

	const EXPRESSION* pLeft =Left(pExpression);
	const EXPRESSION* pRight =Right(pExpression);
	ATLASSERT(pExpression->iIndex!=pLeft->iIndex && pExpression->iIndex!=pRight->iIndex);
	PTSTR p =pszExpression;
	int n =nMax;
	bool fParentheses =((MULTIPLY==pExpression->iOperator || DIVIDE==pExpression->iOperator) &&
		(ADD==pLeft->iOperator ||SUBTRACT==pLeft->iOperator));
	if(fParentheses)
	{
		*p++=_T('(');
		--n;
	}
	int len =ToString(pLeft,p,n);
	if(!len)
		return 0;
	p +=len;
	n =nMax-(int)(p-pszExpression);
	if(n<4)
		return 0;
	if(fParentheses)
	{
		*p++=_T(')');
		--n;
	}

	const TCHAR szOperators[] =_T(" +-*//");
	*p =szOperators[pExpression->iOperator];
	++p;
	--n;

	fParentheses =((ADD!=pExpression->iOperator) && (ADD==pRight->iOperator ||SUBTRACT==pRight->iOperator)) ||
		((DIVIDE==pExpression->iOperator || PROPER_FRACTION==pExpression->iOperator) &&(0!=pRight->iOperator) );
	if(fParentheses)
	{
		*p++=_T('(');
		--n;
	}
	len =ToString(pRight,p,n);
	if(!len)
		return 0;
	p +=len;
	if(fParentheses)
	{
		if((int)(p-pszExpression)>=(nMax-1))
			return 0;
		*p++=_T(')');
		*p =0;
	}
	return (int)(p-pszExpression);
}

// ------------------------------------------------------------------------------------------------
// CStore

	const WORD pQuestions[] ={
		0x1128,0x1136,0x1137,0x1138,0x1139,0x1145,0x1146,0x1147,0x1148,0x1155,0x1156,0x1226,0x122a,0x1234,0x1235,0x1236,
		0x1237,0x1238,0x1239,0x123a,0x1244,0x1246,0x1248,0x1249,0x124a,0x1256,0x1257,0x1258,0x1259,0x1266,0x1267,0x1268,
		0x1269,0x126a,0x1278,0x127a,0x1288,0x1289,0x1334,0x1335,0x1337,0x1339,0x1344,0x1345,0x1347,0x1348,0x1349,0x134a,
		0x1358,0x1359,0x1366,0x1367,0x1368,0x1369,0x136a,0x1388,0x1389,0x1445,0x1447,0x1448,0x144a,0x1468,0x1478,0x1488,
		0x1489,0x14aa,0x1566,0x1569,0x1588,0x158a,0x159a,0x166a,0x167a,0x1689,0x168a,0x1699,0x177a,0x1789,0x178a,0x1888,
		0x2223,0x2224,0x2228,0x2233,0x2236,0x2238,0x2239,0x2245,0x2246,0x2247,0x2248,0x224a,0x2256,0x225a,0x2268,0x226a,
		0x2278,0x2288,0x228a,0x22aa,0x2336,0x2337,0x2338,0x2339,0x2344,0x2346,0x2347,0x2348,0x2349,0x234a,0x2355,0x2356,
		0x2357,0x2359,0x2366,0x2367,0x2368,0x2369,0x236a,0x2378,0x2379,0x2388,0x2399,0x239a,0x2444,0x2445,0x2446,0x2448,
		0x244a,0x2456,0x2458,0x2459,0x2466,0x2467,0x2468,0x2469,0x246a,0x2478,0x247a,0x2488,0x248a,0x2567,0x2568,0x256a,
		0x257a,0x2589,0x2666,0x2668,0x266a,0x2679,0x2688,0x2689,0x268a,0x26aa,0x2778,0x2788,0x279a,0x2888,0x288a,0x2899,
		0x28aa,0x3336,0x3338,0x3345,0x3346,0x3348,0x3349,0x3356,0x3359,0x3367,0x3369,0x336a,0x3379,0x3389,0x3399,0x3446,
		0x3448,0x3449,0x3457,0x3458,0x345a,0x3466,0x3468,0x346a,0x3477,0x3479,0x347a,0x3489,0x348a,0x3499,0x3558,0x3568,
		0x3569,0x356a,0x3578,0x3579,0x357a,0x3588,0x3666,0x3667,0x3668,0x3669,0x3678,0x3679,0x3688,0x3689,0x3699,0x369a,
		0x3777,0x3778,0x3788,0x3799,0x379a,0x37aa,0x3888,0x3889,0x3899,0x389a,0x38aa,0x3999,0x4446,0x4448,0x4456,0x4458,
		0x4469,0x446a,0x4479,0x4488,0x448a,0x4556,0x4566,0x456a,0x4578,0x4579,0x4666,0x4667,0x4668,0x4669,0x4677,0x4678,
		0x467a,0x4688,0x4689,0x4699,0x469a,0x46aa,0x4788,0x4789,0x479a,0x4888,0x488a,0x48aa,0x5577,0x5667,0x566a,0x5678,
		0x568a,0x6666,0x6669,0x678a,0x6799,0x688a,
		0x111c,0x112b,0x112c,0x112d,0x113c,0x11ad,0x11bc,0x11bd,0x11cc,0x11cd,0x122b,0x122c,0x122d,0x123b,0x124b,0x124c,
		0x124d,0x125c,0x126c,0x129d,0x12ac,0x12bb,0x12bd,0x12cc,0x12dd,0x133b,0x133c,0x134b,0x134c,0x135c,0x135d,0x136c,
		0x137d,0x138c,0x138d,0x139b,0x139c,0x13ab,0x13cc,0x144c,0x145b,0x146c,0x146d,0x147c,0x147d,0x148b,0x148c,0x148d,
		0x149b,0x149c,0x156c,0x156d,0x157b,0x157c,0x157d,0x158b,0x158c,0x15ac,0x166b,0x166c,0x166d,0x167b,0x167c,0x168b,
		0x168c,0x169d,0x16cc,0x177b,0x179c,0x188b,0x189c,0x18ac,0x18ad,0x19bc,0x1acc,0x1bcd,0x222c,0x223c,0x224b,0x224d,
		0x226c,0x227d,0x228c,0x229b,0x229c,0x22bd,0x22cc,0x233c,0x233d,0x234b,0x234c,0x234d,0x235b,0x235d,0x236b,0x236c,
		0x236d,0x237b,0x237c,0x238b,0x238c,0x23ac,0x23ad,0x23bd,0x23cc,0x244c,0x245c,0x245d,0x246b,0x246c,0x246d,0x247b,
		0x248b,0x248c,0x249c,0x249d,0x24ab,0x24ac,0x24bb,0x24cc,0x24dd,0x255c,0x255d,0x256b,0x256c,0x257b,0x257d,0x258d,
		0x259c,0x25ab,0x25ad,0x25cc,0x266c,0x267d,0x268b,0x268c,0x268d,0x269b,0x269c,0x26ac,0x26ad,0x26cc,0x277c,0x278b,
		0x278c,0x278d,0x279d,0x27ac,0x27bc,0x288c,0x288d,0x289c,0x28ab,0x28ac,0x28cc,0x299c,0x29ac,0x2aac,0x2abc,0x2acd,
		0x2bbc,0x2bbd,0x2bcc,0x2bdd,0x2ccc,0x2ccd,0x2cdd,0x333c,0x334c,0x335d,0x336b,0x336c,0x337b,0x337c,0x338c,0x339c,
		0x33bc,0x33bd,0x33cc,0x344d,0x345c,0x346b,0x346c,0x347b,0x347c,0x348b,0x348c,0x349c,0x34ac,0x34ad,0x34bc,0x34bd,
		0x34cc,0x356b,0x356c,0x357c,0x358b,0x359c,0x359d,0x35ac,0x35ad,0x366c,0x369b,0x369c,0x369d,0x36ab,0x36ac,0x36cc,
		0x377d,0x378b,0x378c,0x379b,0x379c,0x37ad,0x37bc,0x37cc,0x37cd,0x38bb,0x38cc,0x38cd,0x38dd,0x399c,0x39bc,0x39cc,
		0x3aac,0x444c,0x445b,0x446c,0x447c,0x448c,0x44ac,0x44bd,0x44cc,0x458c,0x45ac,0x45bc,0x45bd,0x45cc,0x45cd,0x468c,
		0x469c,0x46ac,0x46bb,0x46cc,0x46dd,0x478d,0x479c,0x47ab,0x47ac,0x488c,0x489b,0x489c,0x48ac,0x48bc,0x49bc,0x49cc,
		0x4acc,0x4bcd,0x55bc,0x55bd,0x55cc,0x566c,0x567d,0x568c,0x56bc,0x56bd,0x56cc,0x56cd,0x579d,0x57ac,0x57bb,0x589b,
		0x589c,0x58bc,0x599c,0x5add,0x668c,0x669c,0x66ac,0x66bd,0x66cc,0x67ac,0x67ad,0x67bc,0x67bd,0x67cc,0x67cd,0x689d,
		0x68ac,0x68cc,0x69ab,0x69cc,0x69cd,0x77bd,0x77cc,0x78bc,0x78bd,0x78cc,0x78cd,0x79dd,0x88bd,0x88cc,0x89ad,0x89bd,
		0x89cc,0x89cd,0x99bd,0x99cc,0x9abc,0x9abd,0x9acc,0xaabd,0xaacc,0xabbd,0xabcc,0xbbbd,0xbbcc,0xbbcd,0xbccc,0xbccd,
		0xbcdd,0xbddd,0xcccc,0xcccd,0xccdd,	

		0x1126,0x112a,0x1157,0x1166,0x1225,0x1227,0x1228,0x1245,0x1247,0x125a,0x1279,0x1333,0x1336,0x1338,0x133a,0x1356,
		0x1357,0x135a,0x137a,0x13aa,0x1444,0x1446,0x1449,0x1455,0x1457,0x1458,0x1459,0x145a,0x1466,0x149a,0x1556,0x1567,
		0x156a,0x1578,0x1589,0x1599,0x15aa,0x169a,0x1779,0x1788,0x1799,0x1889,0x222a,0x2234,0x2237,0x2244,0x2249,0x2255,
		0x2266,0x2267,0x2269,0x2333,0x2335,0x233a,0x2345,0x2358,0x235a,0x237a,0x2389,0x238a,0x2447,0x2457,0x2479,0x2499,
		0x249a,0x2559,0x2566,0x2588,0x258a,0x25aa,0x2667,0x2669,0x2678,0x267a,0x269a,0x27aa,0x289a,0x3334,0x3337,0x333a,
		0x3344,0x3347,0x335a,0x3368,0x338a,0x3445,0x3447,0x3455,0x3459,0x3469,0x3556,0x3557,0x3566,0x3567,0x3589,0x3599,
		0x359a,0x3677,0x377a,0x4447,0x444a,0x4455,0x445a,0x4468,0x4478,0x4555,0x4559,0x455a,0x4567,0x4569,0x4577,0x4588,
		0x4589,0x458a,0x459a,0x45aa,0x468a,0x4778,0x499a,0x5556,0x5559,0x5566,0x5567,0x5568,0x5578,0x5589,0x558a,0x5688,
		0x5689,0x5699,0x569a,0x56aa,0x5788,0x5789,0x5888,0x5889,0x588a,0x59aa,0x6668,0x6679,0x6689,0x668a,0x669a,0x6889,
		0x6899,0x6aaa,
		0x114c,0x119d,0x11ac,0x11bb,0x11dd,0x123c,0x123d,0x125d,0x128d,0x129c,0x12ab,0x12ad,0x12bc,0x12cd,0x134d,0x135b,
		0x136b,0x136d,0x139d,0x13ac,0x13bb,0x13bc,0x13cd,0x13dd,0x145c,0x146b,0x14ab,0x14ac,0x14cc,0x155d,0x159b,0x159c,
		0x168d,0x169c,0x178b,0x178c,0x179d,0x188c,0x189b,0x199c,0x1abc,0x1acd,0x222b,0x222d,0x224c,0x225b,0x233b,0x237d,
		0x239d,0x23bc,0x23cd,0x244b,0x244d,0x245b,0x248d,0x24ad,0x255b,0x256d,0x258b,0x258c,0x259b,0x25ac,0x25cd,0x267c,
		0x26ab,0x26bc,0x26bd,0x26cd,0x277b,0x279b,0x27ab,0x27cc,0x289b,0x289d,0x28ad,0x29ab,0x29ad,0x29bb,0x29bd,0x29cd,
		0x2aad,0x2abd,0x2bcd,0x334b,0x335c,0x336d,0x339b,0x33cd,0x344c,0x345b,0x345d,0x349b,0x34cd,0x355b,0x357b,0x358c,
		0x35ab,0x35bb,0x35cc,0x35cd,0x35dd,0x366d,0x367c,0x367d,0x368c,0x368d,0x36bb,0x36bc,0x36dd,0x378d,0x37ab,0x388b,
		0x388c,0x389b,0x389c,0x389d,0x38ab,0x38bc,0x399b,0x39ab,0x39ac,0x39ad,0x39cd,0x3abd,0x448b,0x448d,0x449c,0x44ad,
		0x44cd,0x457b,0x457c,0x457d,0x458b,0x458d,0x459c,0x459d,0x45ab,0x45ad,0x45bb,0x466c,0x467c,0x469d,0x46ab,0x46bc,
		0x46cd,0x477b,0x478c,0x479d,0x47cc,0x47cd,0x489d,0x48bb,0x48bd,0x48cc,0x48cd,0x48dd,0x49ad,0x4acd,0x4ccc,0x556b,
		0x558d,0x55cd,0x567c,0x569b,0x569c,0x56ab,0x56ad,0x57dd,0x588d,0x58ab,0x58bd,0x599b,0x59ad,0x59cc,0x59cd,0x5aac,
		0x5bcc,0x666c,0x667c,0x669b,0x66ad,0x678b,0x679c,0x688c,0x689c,0x68bb,0x68bd,0x68dd,0x699b,0x699c,0x69ac,0x6acc,
		0x77bc,0x77cd,0x789c,0x78ad,0x799d,0x79ab,0x79ac,0x79bb,0x79bc,0x7aab,0x7acc,0x7ccd,0x888c,0x889b,0x88ad,0x89ac,
		0x89bc,0x8aac,0x8abb,0x8acc,0x8add,0x99bc,0x99cd,0x9aad,0x9acd,0x9bbb,0x9bdd,0xabbc,0xabcd,0xaccd,0xacdd,0xbbbc,
		0xcddd,	

		0x1118,0x1127,0x1129,0x1134,0x1135,0x113a,0x1144,0x1149,0x1158,0x1168,0x1224,0x1229,0x1233,0x1255,0x1377,0x1378,
		0x1379,0x138a,0x1399,0x1467,0x1469,0x1477,0x1479,0x1559,0x1568,0x1579,0x157a,0x1669,0x1679,0x1688,0x179a,0x188a,
		0x2257,0x2259,0x2277,0x2289,0x2377,0x245a,0x2489,0x2557,0x2569,0x2577,0x2579,0x259a,0x2699,0x2889,0x29aa,0x3333,
		0x3335,0x3355,0x3378,0x339a,0x3456,0x34aa,0x367a,0x368a,0x3789,0x399a,0x4444,0x4457,0x447a,0x4489,0x4568,0x466a,
		0x4679,0x478a,0x4889,0x489a,0x5555,0x557a,0x5588,0x5599,0x559a,0x55aa,0x5669,0x5779,0x578a,0x57aa,0x666a,0x6688,
		0x677a,0x6789,0x699a,0x788a,0x789a,
		0x111b,0x111d,0x113b,0x113d,0x126b,0x126d,0x127b,0x137c,0x138b,0x144b,0x145d,0x149d,0x155b,0x156b,0x159d,0x15ab,
		0x15ad,0x15bc,0x15cc,0x16ac,0x16ad,0x16bc,0x16cd,0x179b,0x17ac,0x17ad,0x17cc,0x17cd,0x189d,0x18ab,0x18bc,0x18bd,
		0x19ac,0x19ad,0x19bb,0x19bd,0x19cc,0x1bbd,0x1bcc,0x1bdd,0x1ccd,0x223b,0x223d,0x225c,0x227c,0x22ad,0x22bc,0x22cd,
		0x23bb,0x23dd,0x267b,0x28bc,0x28cd,0x2abb,0x333b,0x338d,0x339d,0x33ad,0x344b,0x346d,0x348d,0x349d,0x356d,0x358d,
		0x35bc,0x36bd,0x36cd,0x379d,0x38ac,0x399d,0x39bd,0x3abc,0x3bcc,0x3ccd,0x445c,0x445d,0x447d,0x449b,0x44bc,0x456b,
		0x456c,0x456d,0x468d,0x479b,0x47bc,0x47bd,0x48ab,0x499c,0x49ac,0x49bb,0x4aab,0x4abc,0x555c,0x558b,0x558c,0x559b,
		0x55ab,0x55ad,0x55bb,0x55dd,0x568d,0x569d,0x56ac,0x579b,0x579c,0x57ad,0x57bd,0x57cc,0x589d,0x58ac,0x59ab,0x59bd,
		0x5abb,0x5acd,0x667b,0x669d,0x66bc,0x66cd,0x677b,0x678c,0x688b,0x689b,0x68ad,0x68bc,0x6abc,0x6acd,0x6bbc,0x6ccc,
		0x6cdd,0x777c,0x778b,0x77ad,0x788c,0x788d,0x789d,0x78ab,0x79cc,0x7acd,0x888b,0x888d,0x889c,0x88bc,0x88cd,0x899c,
		0x8acd,0x999c,0x99ad,0x9bcc,0x9bcd,0xaaac,0xaaad,0xaabc,0xaacd,0xaccc,0xaddd,	

		0x114a,0x1169,0x117a,0x1188,0x128a,0x2225,0x2227,0x2229,0x2235,0x227a,0x229a,0x23aa,0x2455,0x2558,0x2578,0x3339,
		0x3357,0x3366,0x3478,0x3559,0x35aa,0x36aa,0x3779,0x39aa,0x4445,0x4449,0x4557,0x4558,0x457a,0x4599,0x4777,0x4799,
		0x47aa,0x4899,0x5666,0x5668,0x5677,0x5679,0x577a,0x579a,0x667a,0x6888,0x689a,0x779a,0x7889,0x78aa,0x888a,
		0x116c,0x127c,0x155c,0x177c,0x1aac,0x1bbc,0x1ccc,0x1cdd,0x226b,0x22ab,0x239c,0x25bc,0x266b,0x266d,0x277d,0x27cd,
		0x288b,0x28bb,0x28dd,0x299b,0x299d,0x29dd,0x2aab,0x2bbb,0x2ddd,0x337d,0x355c,0x377c,0x37bb,0x37dd,0x39bb,0x39dd,
		0x3bbc,0x3ccc,0x3cdd,0x446b,0x45dd,0x478b,0x47bb,0x47dd,0x49ab,0x4aac,0x4abd,0x56bb,0x56dd,0x668b,0x69bc,0x69bd,
		0x6bcd,0x7aac,0x7abd,0x88ac,	

		0x1277,0x139a,0x146a,0x155a,0x1666,0x223a,0x2258,0x2449,0x2477,0x2789,0x3444,0x344a,0x366a,0x388a,0x44aa,0x67aa,
		0x129b,0x147b,0x158d,0x15bb,0x16bd,0x17dd,0x226d,0x238d,0x247c,0x24bc,0x334d,0x357d,0x366b,0x444b,0x446d,0x488b,
		0x488d,0x57ab,0x58cc,0x5aab,0x5aad,0x666b,0x668d,0x67bb,0x68ab,0x6aad,0x6bcc,0x6ccd,0x788b,0x889d,0x89bb,0x8bcc,
		0x9ccc,	

		0x1346,0x1456,0x1555,0x1668,0x24aa,0x255a,0x277a,0x3377,0x3388,0x4477,
		0x18cc,0x22bb,0x22dd,0x235c,0x557b,0x577b,	
		0
	};
	const BYTE pHints[] ={
		0x18,0x14,0x23,0x3e,0x1e,0x1c,0x3e,0x1c,0x23,0x41,0x22,0x39,0x27,0x39,0x1e,0x19,
		0x3e,0x27,0x3e,0x1d,0x1e,0x21,0x27,0x1e,0x3d,0x18,0x1c,0x1e,0x23,0x1e,0x23,0x3e,
		0x3d,0x23,0x22,0x39,0x39,0x14,0x21,0x19,0x3d,0x27,0x1e,0x1d,0x3d,0x1e,0x27,0x2b,
		0x18,0x27,0x18,0x39,0x21,0x23,0x42,0x18,0x38,0x3d,0x41,0x39,0x27,0x27,0x3d,0x42,
		0x39,0x19,0x42,0x27,0x26,0x14,0x19,0x27,0x14,0x14,0x27,0x19,0x14,0x1c,0x19,0x19,
		0x34,0x1c,0x23,0x1e,0x23,0x38,0x2b,0x23,0x38,0x3e,0x18,0x2b,0x1c,0x23,0x23,0x38,
		0x38,0x34,0x3c,0x14,0x19,0x27,0x21,0x1c,0x39,0x21,0x18,0x18,0x38,0x3d,0x19,0x18,
		0x39,0x3d,0x38,0x3d,0x39,0x18,0x1c,0x23,0x1e,0x26,0x38,0x14,0x19,0x19,0x19,0x3c,
		0x39,0x39,0x39,0x14,0x18,0x3c,0x38,0x2b,0x27,0x3e,0x23,0x22,0x14,0x1c,0x18,0x38,
		0x14,0x14,0x34,0x27,0x14,0x14,0x14,0x38,0x22,0x19,0x14,0x18,0x19,0x39,0x19,0x19,
		0x41,0x3c,0x34,0x23,0x38,0x22,0x1c,0x3e,0x18,0x3c,0x38,0x23,0x23,0x23,0x14,0x21,
		0x34,0x19,0x18,0x1d,0x34,0x34,0x1d,0x38,0x38,0x3c,0x14,0x14,0x27,0x1e,0x34,0x21,
		0x14,0x14,0x38,0x14,0x14,0x14,0x19,0x1c,0x34,0x14,0x14,0x38,0x39,0x1c,0x38,0x22,
		0x14,0x34,0x26,0x18,0x38,0x19,0x34,0x27,0x34,0x19,0x34,0x19,0x34,0x3c,0x22,0x14,
		0x34,0x14,0x14,0x14,0x23,0x34,0x26,0x34,0x14,0x38,0x34,0x27,0x14,0x3c,0x14,0x14,
		0x38,0x34,0x2b,0x34,0x2b,0x34,0x14,0x18,0x19,0x39,0x14,0x19,0x14,0x14,0x19,0x18,
		0x34,0x14,0x34,0x14,0x34,0x1d,	
		0x14,0x1c,0x3e,0x3e,0x22,0x43,0x18,0x18,0x18,0x41,0x3d,0x21,0x41,0x2b,0x1c,0x3e,
		0x23,0x22,0x14,0x43,0x19,0x19,0x21,0x1e,0x41,0x27,0x27,0x27,0x18,0x1c,0x23,0x3e,
		0x14,0x14,0x43,0x14,0x43,0x19,0x42,0x27,0x2b,0x21,0x14,0x14,0x43,0x14,0x3e,0x19,
		0x19,0x19,0x14,0x43,0x14,0x43,0x19,0x19,0x19,0x38,0x14,0x43,0x19,0x43,0x19,0x19,
		0x26,0x2b,0x38,0x19,0x26,0x27,0x2b,0x26,0x2b,0x26,0x26,0x27,0x34,0x22,0x3c,0x3e,
		0x2b,0x14,0x3e,0x14,0x34,0x18,0x18,0x34,0x1d,0x27,0x1e,0x1d,0x27,0x34,0x3e,0x39,
		0x14,0x3d,0x14,0x14,0x2b,0x3d,0x19,0x21,0x3e,0x34,0x27,0x14,0x3c,0x14,0x3c,0x14,
		0x3c,0x14,0x2b,0x19,0x38,0x19,0x19,0x38,0x18,0x14,0x27,0x14,0x21,0x3c,0x3c,0x19,
		0x19,0x19,0x3e,0x22,0x34,0x19,0x27,0x19,0x3c,0x19,0x14,0x2b,0x14,0x42,0x19,0x19,
		0x27,0x27,0x3c,0x42,0x26,0x34,0x27,0x39,0x22,0x43,0x21,0x34,0x26,0x34,0x26,0x3c,
		0x34,0x34,0x26,0x38,0x34,0x27,0x34,0x14,0x14,0x14,0x23,0x14,0x14,0x1c,0x23,0x22,
		0x38,0x18,0x18,0x14,0x14,0x14,0x34,0x23,0x38,0x39,0x3d,0x27,0x26,0x19,0x19,0x21,
		0x21,0x38,0x27,0x18,0x27,0x14,0x19,0x19,0x14,0x21,0x1d,0x19,0x3c,0x19,0x38,0x26,
		0x19,0x34,0x19,0x19,0x34,0x34,0x18,0x26,0x27,0x34,0x34,0x2b,0x34,0x34,0x22,0x21,
		0x19,0x14,0x14,0x23,0x23,0x34,0x22,0x18,0x18,0x27,0x34,0x19,0x21,0x21,0x18,0x14,
		0x23,0x19,0x19,0x34,0x18,0x19,0x19,0x19,0x23,0x19,0x19,0x34,0x14,0x23,0x14,0x22,
		0x14,0x14,0x34,0x18,0x18,0x34,0x34,0x22,0x19,0x21,0x21,0x18,0x19,0x19,0x19,0x18,
		0x19,0x22,0x34,0x22,0x34,0x22,0x23,0x18,0x18,0x3d,0x19,0x19,0x21,0x21,0x18,0x19,
		0x19,0x22,0x19,0x26,0x22,0x18,0x18,0x19,0x21,0x21,0x18,0x18,0x18,0x18,0x19,0x21,
		0x21,0x18,0x18,0x18,0x19,0x1e,0x1e,0x18,0x18,0x21,0x1e,0x14,0x18,0x22,0x21,0x14,
		0x26,0x14,0x14,0x23,0x14,	

		0x14,0x1e,0x1e,0x1e,0x1c,0x23,0x19,0x19,0x18,0x3e,0x39,0x19,0x1d,0x23,0x1c,0x3d,
		0x1e,0x39,0x3d,0x14,0x19,0x23,0x1c,0x39,0x3d,0x18,0x21,0x27,0x21,0x14,0x3d,0x39,
		0x27,0x18,0x23,0x14,0x19,0x19,0x14,0x14,0x19,0x19,0x3c,0x14,0x18,0x38,0x3c,0x18,
		0x38,0x1c,0x3c,0x14,0x3d,0x34,0x19,0x3c,0x1c,0x3c,0x27,0x34,0x27,0x1e,0x1e,0x14,
		0x38,0x34,0x34,0x38,0x27,0x18,0x41,0x14,0x18,0x14,0x23,0x22,0x1c,0x1c,0x14,0x3c,
		0x38,0x1e,0x1c,0x18,0x14,0x39,0x1c,0x3e,0x1d,0x1c,0x46,0x1d,0x18,0x1e,0x3c,0x22,
		0x18,0x1e,0x34,0x14,0x34,0x1e,0x4b,0x1c,0x38,0x39,0x34,0x14,0x1d,0x14,0x39,0x42,
		0x1d,0x18,0x23,0x3e,0x26,0x19,0x19,0x34,0x14,0x14,0x3c,0x14,0x14,0x34,0x1c,0x14,
		0x18,0x4b,0x18,0x1e,0x19,0x14,0x34,0x21,0x14,0x19,0x14,0x18,0x14,0x14,0x1c,0x34,
		0x1e,0x19,	
		0x22,0x14,0x14,0x14,0x1e,0x18,0x3d,0x2b,0x14,0x14,0x14,0x19,0x19,0x18,0x2b,0x2b,
		0x1c,0x1c,0x19,0x19,0x19,0x3d,0x39,0x18,0x18,0x1c,0x19,0x14,0x46,0x14,0x19,0x18,
		0x2b,0x1c,0x27,0x18,0x21,0x27,0x1c,0x21,0x18,0x23,0x41,0x41,0x18,0x2b,0x46,0x38,
		0x2b,0x19,0x18,0x46,0x46,0x1e,0x46,0x2b,0x46,0x1d,0x27,0x18,0x38,0x27,0x42,0x26,
		0x41,0x38,0x1c,0x3e,0x46,0x3c,0x38,0x18,0x1e,0x21,0x3c,0x18,0x38,0x38,0x3c,0x27,
		0x21,0x14,0x1d,0x34,0x38,0x34,0x23,0x41,0x46,0x3c,0x38,0x2b,0x18,0x14,0x27,0x1c,
		0x38,0x19,0x38,0x23,0x18,0x27,0x14,0x34,0x27,0x19,0x41,0x26,0x41,0x27,0x23,0x19,
		0x3d,0x38,0x22,0x42,0x2b,0x2b,0x14,0x19,0x14,0x34,0x19,0x22,0x23,0x34,0x14,0x14,
		0x41,0x34,0x14,0x27,0x27,0x38,0x38,0x34,0x1d,0x19,0x4b,0x3d,0x22,0x19,0x2b,0x2b,
		0x2b,0x34,0x34,0x34,0x4b,0x27,0x41,0x41,0x14,0x18,0x18,0x41,0x22,0x22,0x39,0x38,
		0x23,0x41,0x18,0x1e,0x14,0x23,0x19,0x18,0x19,0x19,0x23,0x19,0x42,0x14,0x23,0x21,
		0x21,0x14,0x38,0x14,0x41,0x19,0x19,0x19,0x18,0x19,0x2b,0x18,0x27,0x19,0x2b,0x42,
		0x41,0x41,0x18,0x19,0x19,0x27,0x19,0x19,0x18,0x19,0x22,0x23,0x14,0x23,0x38,0x18,
		0x19,0x19,0x19,0x38,0x18,0x41,0x41,0x19,0x18,0x19,0x18,0x19,0x18,0x46,0x18,0x41,
		0x19,	

		0x14,0x1c,0x23,0x14,0x1c,0x23,0x14,0x23,0x22,0x14,0x14,0x14,0x18,0x3e,0x22,0x26,
		0x18,0x23,0x22,0x1c,0x27,0x18,0x23,0x14,0x1c,0x22,0x39,0x1c,0x18,0x18,0x22,0x1c,
		0x3c,0x1e,0x1e,0x3c,0x38,0x38,0x27,0x3c,0x39,0x34,0x39,0x3c,0x1e,0x1c,0x42,0x34,
		0x3c,0x41,0x34,0x3c,0x18,0x38,0x39,0x1d,0x1d,0x19,0x34,0x1c,0x14,0x3c,0x14,0x1d,
		0x1e,0x39,0x14,0x18,0x41,0x18,0x4b,0x4b,0x34,0x4b,0x34,0x14,0x14,0x39,0x34,0x22,
		0x19,0x27,0x3d,0x34,0x23,	
		0x1c,0x23,0x1c,0x23,0x39,0x39,0x39,0x22,0x3d,0x27,0x2b,0x39,0x27,0x18,0x14,0x1c,
		0x23,0x22,0x14,0x21,0x1c,0x18,0x23,0x1c,0x26,0x14,0x21,0x1c,0x2b,0x1c,0x26,0x1c,
		0x18,0x21,0x18,0x23,0x26,0x14,0x18,0x22,0x1c,0x1e,0x1c,0x38,0x38,0x41,0x41,0x41,
		0x39,0x39,0x1e,0x1c,0x1c,0x1e,0x34,0x1c,0x14,0x41,0x39,0x1c,0x27,0x1d,0x27,0x39,
		0x26,0x1d,0x1c,0x3c,0x21,0x21,0x14,0x14,0x14,0x14,0x2b,0x34,0x38,0x1c,0x41,0x1d,
		0x18,0x27,0x27,0x21,0x19,0x38,0x18,0x19,0x21,0x38,0x3c,0x43,0x14,0x38,0x14,0x23,
		0x34,0x41,0x4b,0x4b,0x1c,0x23,0x39,0x14,0x18,0x23,0x14,0x38,0x38,0x18,0x34,0x22,
		0x41,0x14,0x38,0x38,0x41,0x41,0x34,0x18,0x14,0x2b,0x18,0x26,0x22,0x27,0x43,0x21,
		0x41,0x14,0x14,0x41,0x14,0x1d,0x18,0x1e,0x38,0x1c,0x34,0x14,0x38,0x41,0x41,0x27,
		0x23,0x14,0x41,0x38,0x1c,0x14,0x41,0x41,0x41,0x34,0x46,	

		0x14,0x14,0x14,0x14,0x22,0x3c,0x3c,0x1c,0x3c,0x43,0x22,0x26,0x1e,0x46,0x34,0x41,
		0x38,0x42,0x22,0x46,0x46,0x4b,0x46,0x4b,0x41,0x23,0x46,0x46,0x26,0x4b,0x46,0x4b,
		0x4b,0x4b,0x46,0x23,0x4b,0x22,0x21,0x27,0x2b,0x21,0x27,0x22,0x23,0x26,0x23,	
		0x14,0x22,0x46,0x46,0x46,0x46,0x46,0x4b,0x23,0x3c,0x26,0x26,0x46,0x46,0x46,0x27,
		0x46,0x4b,0x4b,0x46,0x46,0x19,0x46,0x46,0x46,0x38,0x46,0x46,0x4b,0x4b,0x4b,0x4b,
		0x46,0x46,0x4b,0x2b,0x4b,0x27,0x4b,0x4b,0x27,0x27,0x2b,0x4b,0x4b,0x2b,0x26,0x2b,
		0x27,0x27,0x2b,0x2b,	

		0x3e,0x1c,0x21,0x27,0x21,0x1e,0x1e,0x23,0x1e,0x1d,0x14,0x23,0x21,0x3d,0x3e,0x26,
		0x14,0x14,0x2b,0x3e,0x3e,0x3e,0x1c,0x1d,0x18,0x22,0x2b,0x3d,0x3d,0x23,0x2b,0x3d,
		0x3d,0x22,0x21,0x3d,0x3d,0x23,0x2b,0x22,0x27,0x27,0x39,0x3d,0x23,0x2b,0x22,0x21,
		0x21,	

		0x59,0x46,0x54,0x5d,0x59,0x5c,0x47,0x58,0x42,0x58,	
		0x46,0x58,0x58,0x42,0x43,0x47,	
		0
	};

CStore::CStore()
{
}
void CStore::Init(int nDifficultyMin, int nDifficultyMax, bool fIncludeJQK)
{
	const int pCounts10[] ={
		262,
		146,
		85,
		47,
		16,
		10,
		0
	};
	const int pCounts13[] ={
		262+325,
		146+225,
		85+155,
		47+52,
		16+33,
		10+6,
		0
	};
	const WORD* ppQuestions[] ={
		pQuestions,
		pQuestions+587,
		pQuestions+958,
		pQuestions+1198,
		pQuestions+1297,
		pQuestions+1346,
		0
	};

	m_questions.RemoveAll();
	const int* pCounts =(fIncludeJQK?pCounts13:pCounts10);
	for(int i=nDifficultyMin;i<=nDifficultyMax;i++)
	{
		const WORD* p =ppQuestions[i];
		for(int j=0;j<pCounts[i];j++)
		{
			m_questions.Add(p[j]);
		}
	}
}
bool CStore::Rand(short pOperands[])
{
	if(m_questions.IsEmpty())
		return false;
	srand(GetTickCount());
	unsigned int nRandValue =0;
	if(0!=rand_s(&nRandValue))
		return false;
	WORD element =m_questions[nRandValue%m_questions.GetCount()];
	pOperands[0] =(element>>12)&0xF;
	pOperands[1] =(element>>8)&0xF;
	pOperands[2] =(element>>4)&0xF;
	pOperands[3] =element&0xF;
	return true;
}
void CStore::Add(const short pOperands[])
{
	m_questions.Add( (pOperands[0]<<12)|(pOperands[1]<<8)|(pOperands[2]<<4)|pOperands[3] );
}
void CStore::Remove(const short pOperands[])
{
	const WORD element =(pOperands[0]<<12)|(pOperands[1]<<8)|(pOperands[2]<<4)|pOperands[3];
	for(int i=(int)m_questions.GetCount()-1;i>=0;i--)
	{
		if(element==m_questions[i])
		{
			// remove at i
			m_questions[i] =m_questions[m_questions.GetCount()-1];
			m_questions.SetCount(m_questions.GetCount()-1);
		}
	}
}
bool CStore::IsEmpty() const
{
	return m_questions.IsEmpty();
}

// 获取第一步提示
bool CStore::GetFirstStep(const short pOperands[], __int8& iOperator, __int8& iLeft, __int8& iRight)
{
	const WORD element =(pOperands[0]<<12)|(pOperands[1]<<8)|(pOperands[2]<<4)|pOperands[3];
	for(int i=sizeof(pQuestions)/sizeof(WORD)-2;i>=0;i--)
	{
		if(pQuestions[i]==element)
		{
			BYTE hint =pHints[i];
			iOperator =(hint>>4);
			iLeft =(hint&0x3);
			iRight =((hint>>2)&0x3);
			return true;
		}
	}
	ATLASSERT(!_T("Error operands"));
	return false;
}

// ------------------------------------------------------------------------------------------------
// CGame

CGame::CGame()
	:m_nDifficulty(DIFFICULTY_LOWEST),
	m_fIncludeJQK(false),
	m_fKnowledgeware(false),
	m_fSemiautomatic(false),
	m_nSuccess(0),
	m_nFail(0)
{
}
void CGame::Init()
{
	m_nSuccess =0;
	m_nFail =0;
	m_histories.RemoveAll();

	int nDifficultyMin =0;
	if(m_nDifficulty>=DIFFICULTY_HIGH)
	{
		nDifficultyMin =(m_fKnowledgeware?DIFFICULTY_NORMAL:DIFFICULTY_LOW);
	}
	else if(m_nDifficulty>=DIFFICULTY_LOWEST)
	{
		nDifficultyMin =DIFFICULTY_LOWEST;
	}
	else
	{
		nDifficultyMin =0;
	}
	m_store.Init(nDifficultyMin,m_nDifficulty,m_fIncludeJQK);
	m_steps.RemoveAll();
}
// 新步骤
bool CGame::BeginQuestion()
{
	ATLASSERT(m_steps.IsEmpty());
	short pOperands[NUM_OPERAND];
	if(!m_store.Rand(pOperands))
		return false;
	m_make24.Attach(pOperands);
	unsigned int nRandValue =0;
	rand_s(&nRandValue);

	STEP step ={0};
	for(__int8 i=0;i<NUM_OPERAND*2-1;i++)
	{
		EXPRESSION* p =step.pExpressions+i;
		p->iIndex =i;
		p->nDenominator =1;
		p->iLeft =-1;
		p->iRight =-1;
	}
	for(__int8 j=0;j<NUM_OPERAND;j++)
	{
		step.pPositions[j] =j;
		step.pExpressions[j].nNumerator =pOperands[j];
		m_pSuits[j] =(__int8)((nRandValue>>(j*2))&0x3);
		if(j>0 && (pOperands[j-1]==pOperands[j]) && (m_pSuits[j-1]==m_pSuits[j]) )
		{
			m_pSuits[j] =(m_pSuits[j]+1)%NUM_SUIT;
		}
	}
	m_steps.Add(step);
	return true;
}
// 结束当前运算步骤，更新得分
bool CGame::EndQuestion()
{
	ATLASSERT(!m_steps.IsEmpty());
	KEY key;
	bool fResolved =IsResolved(&key);
	if(fResolved)
	{
		m_nSuccess++;
		m_histories.Add(key);
	}
	else
	{
		m_nFail++;
	}
	if(m_fKnowledgeware)
	{
		short pOperands[NUM_OPERAND];
		const EXPRESSION* pExpressions =m_steps[m_steps.GetCount()-1].pExpressions;
		for(__int8 i=0;i<NUM_OPERAND;i++)
		{
			pOperands[i] =pExpressions[i].nNumerator;
		}
		if(fResolved)
		{
			m_store.Remove(pOperands);
		}
		else
		{
			m_store.Add(pOperands);
		}
	}
	m_steps.RemoveAll();
	return (!m_store.IsEmpty());
}

bool CGame::IsResolved(KEY* pKey) const
{
	if(pKey)
	{
		*pKey->szExpression =0;
	}
	if(m_steps.GetCount()<=1)
		return false;

	const STEP& step =m_steps[m_steps.GetCount()-1];
	if(step.pExpressions[NUM_OPERAND*2-2].iOperator!=0)
	{
		if (step.pExpressions[NUM_OPERAND*2-2].nDenominator*24!=step.pExpressions[NUM_OPERAND*2-2].nNumerator)
			return false;
		if(pKey)
		{
			m_make24.ToString(step.pExpressions+NUM_OPERAND*2-2,pKey->szExpression,sizeof(pKey->szExpression)/sizeof(TCHAR));
		}
		return true;
	}

	EXPRESSION pExpressions[NUM_OPERAND*2-1];
	memcpy(pExpressions,step.pExpressions,sizeof(pExpressions));
	if(m_fSemiautomatic && (step.pExpressions[NUM_OPERAND*2-3].iOperator!=0) )
	{
		EXPRESSION& result =pExpressions[NUM_OPERAND*2-2];
		for(int i=0;i<NUM_OPERAND;i++)
		{
			__int8 iIndex =step.pPositions[i];
			if(iIndex>=0 && iIndex<NUM_OPERAND*2-3)
			{
				result.nDenominator =1;
				for(__int8 j=ADD;j<=DIVIDE;j++)
				{
					if(FractionalOperate(result,pExpressions[NUM_OPERAND*2-3],pExpressions[iIndex],j))
					{
						if(result.nDenominator*24==result.nNumerator)
						{
							if(pKey)
							{
								m_make24.ToString(&result,pKey->szExpression,sizeof(pKey->szExpression)/sizeof(TCHAR));
							}
							return true;
						}
					}
				}
				break;
			}
		}
	}
	return false;
}
int CGame::GetKeys(KEY pKeys[] ,int nMax)
{
	ATLASSERT(!m_steps.IsEmpty());
	int nKey =m_make24.GetKeys(pKeys,nMax);
	if(!nKey)
	{
		m_make24.AutoOperate();
		nKey =m_make24.GetKeys(pKeys,nMax);
	}
	return nKey;
}

const EXPRESSION* CGame::GetExpression(__int8 iPosition) const
{
	ATLASSERT(!m_steps.IsEmpty());
	if(m_steps.IsEmpty())
		return NULL;
	const STEP& step =m_steps[m_steps.GetCount()-1];
	__int8 iIndex =step.pPositions[iPosition];
	if(iIndex<0)
		return NULL;
	return step.pExpressions+iIndex;
}

void CGame::SetOption(int nDifficulty, bool fIncludeJQK, bool fKnowledgeware, bool fSemiautomatic)
{
	SetDifficulty(nDifficulty);
	m_fIncludeJQK =fIncludeJQK;
	m_fKnowledgeware =fKnowledgeware;
#if defined(_SEMIAUTOMATIC_)
	m_fSemiautomatic =fSemiautomatic;
#endif
}

int CGame::GetSuccessHistories(KEY* pKeys, int nMax) const
{
	int n =(int)m_histories.GetCount();
	for(int i=min(n,nMax)-1;i>=0;i--)
	{
		// 倒序拷贝
		memcpy(pKeys[i].szExpression,m_histories[n-1-i].szExpression,sizeof(pKeys[i].szExpression));
	}
	return n;
}

bool CGame::CanMerge(__int8 iFrom, __int8 iTo, __int8 iOperator) const
{
	const EXPRESSION* pFrom =GetExpression(iFrom);
	const EXPRESSION* pTo =GetExpression(iTo);
	if(!pFrom || !pTo)
		return false;
	return CanOperate(pFrom->iIndex,pTo->iIndex,iOperator);
}
bool CGame::Merge(__int8 iFrom, __int8 iTo, __int8 iOperator)
{
	ATLASSERT(CanMerge(iFrom,iTo,iOperator));
	const EXPRESSION* pFrom =GetExpression(iFrom);
	const EXPRESSION* pTo =GetExpression(iTo);
	if(!pFrom || !pTo)
		return false;
	STEP step =m_steps[m_steps.GetCount()-1];
	for(EXPRESSION* pResult =step.pExpressions+NUM_OPERAND; pResult<step.pExpressions+NUM_OPERAND*2-1; pResult++)
	{
		if(!pResult->iOperator)
		{
			if(IsFractional() ?
				FractionalOperate(*pResult,*pFrom,*pTo,(DIVIDE==iOperator && pFrom->nNumerator*pTo->nDenominator<pTo->nNumerator*pFrom->nDenominator)?PROPER_FRACTION:iOperator):
				Operate(*pResult,*pFrom,*pTo,iOperator) )
			{
				step.pPositions[iFrom] =-1;
				step.pPositions[iTo] =pResult->iIndex;
				m_steps.Add(step);
				return true;
			}
			break;
		}
	}
	return false;
}
bool CGame::CanChangeOperator(__int8 iPosition, __int8 iOperator) const
{
	const EXPRESSION* pExpression =GetExpression(iPosition);
	if(!pExpression)
		return false;
	if((pExpression->iLeft<0) || (pExpression->iOperator==iOperator) )
		return false;
	return CanOperate(pExpression->iLeft,pExpression->iRight,iOperator);
}
bool CGame::ChangeOperator(__int8 iPosition, __int8 iOperator)
{
	ATLASSERT(CanChangeOperator(iPosition,iOperator));
	const EXPRESSION* p =GetExpression(iPosition);
	if(!p)
		return false;
	if((p->iLeft<0) || (p->iOperator==iOperator) )
		return false;
	STEP step =m_steps[m_steps.GetCount()-1];
	EXPRESSION* pExpression =step.pExpressions+p->iIndex;
	EXPRESSION* pLeft =Left(pExpression);
	EXPRESSION* pRight =Right(pExpression);
	if(IsFractional())
	{
		if(!FractionalOperate(*pExpression,*pLeft,*pRight,
			(DIVIDE==iOperator && pLeft->nNumerator*pRight->nDenominator<pRight->nNumerator*pLeft->nDenominator)?PROPER_FRACTION:iOperator))
			return false;
	}
	else
	{
		if(!Operate(*pExpression,*pLeft,*pRight,iOperator) )
			return false;
	}
	m_steps.Add(step);
	return true;
}
__int8 CGame::Step()
{
	if (m_steps.GetCount()!=1)
		return -1;
	short pOperands[NUM_OPERAND];
	const EXPRESSION* pExpressions =m_steps[m_steps.GetCount()-1].pExpressions;
	for(__int8 i=0;i<NUM_OPERAND;i++)
	{
		pOperands[i] =pExpressions[i].nNumerator;
	}
	__int8 iOperator,iLeft,iRight;
	if(!CStore::GetFirstStep(pOperands,iOperator,iLeft,iRight))
		return -1;
	return (Merge(iLeft,iRight,iOperator)?iRight:-1);
}
bool CGame::Undo()
{
	if(m_steps.GetCount()<=1)
		return false;
	m_steps.RemoveAt(m_steps.GetCount()-1);
	return true;
}
void CGame::UndoAll()
{
	if(m_steps.GetCount()<=1)
		return;
	m_steps.RemoveAt(1,m_steps.GetCount()-1);
}

bool CGame::CanOperate(__int8 iLeft, __int8 iRight, __int8 iOperator) const
{
	const EXPRESSION* pExpressions =m_steps[m_steps.GetCount()-1].pExpressions;
	const EXPRESSION* pLeft =pExpressions+iLeft;
	const EXPRESSION* pRight =pExpressions+iRight;
	switch(iOperator)
	{
	case SUBTRACT:
		return (pLeft->nNumerator*pRight->nDenominator > pRight->nNumerator*pLeft->nDenominator);
	case DIVIDE:
		return IsFractional()|| 
			((pLeft->nNumerator*pRight->nDenominator >= pRight->nNumerator*pLeft->nDenominator) &&
			(pLeft->nNumerator*pRight->nDenominator%pRight->nNumerator*pLeft->nDenominator==0));
	default:
		break;
	}
	return true;
}
